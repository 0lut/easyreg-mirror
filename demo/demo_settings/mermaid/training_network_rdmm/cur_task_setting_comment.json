{
    "dataset": {
        "img_after_resize": "image size after resample",
        "load_init_weight": "load init weight for adaptive weighting model",
        "load_training_data_into_memory": "when train network, load all training sample into memory can relieve disk burden"
    },
    "tsk_opt": {
        "save_extra_3d_img": "save extra image"
    },
    "tsk_set": {
        "batch_sz": "batch sz (only for mermaid related method, otherwise set to 1)",
        "continue_train": "for network training method, continue training the model loaded from model_path",
        "criticUpdates": "for network training method, the num determines gradient update every # iter",
        "evaluate_label_list": "evaluate_label_list",
        "gpu_ids": "the gpu id used for network methods",
        "loss": {
            "type": "the similarity measure type"
        },
        "model_path": "if continue_train, the model path should be given here",
        "n_in_channel": "for network training method, the color channel typically set to 1",
        "optim": {
            "adam": {},
            "lr_scheduler": {
                "custom": {}
            }
        },
        "output_orginal_img_type": "output in form of original image",
        "path": {
            "__doc__": "record paths"
        },
        "reg": {
            "affine_net": {
                "acc_multi_step_loss": "accumulate loss from each step",
                "affine_net_iter": "num of step",
                "epoch_activate_extern_loss": "epoch to activate lncc loss",
                "epoch_activate_multi_step": "epoch to activate multi-step affine",
                "epoch_activate_sym": "epoch to activate symmetric forward",
                "epoch_activate_sym_loss": "the epoch to take symmetric loss into backward , only if epoch_activate_sym and epoch_activate_sym_loss",
                "lr_for_multi_step": "if reset_lr_for_multi_step, reset learning rate into # when multi-step begins",
                "reset_lr_for_multi_step": "if True, reset learning rate when multi-step begins",
                "using_complex_net": "use complex version of affine net"
            },
            "compute_inverse_map": "compute the inverse transformation map",
            "low_res_factor": "factor of low-resolution map",
            "mermaid_net": {
                "affine_init_path": "the path of trained affined network",
                "clamp_momentum": "clamp_momentum",
                "clamp_thre": "clamp momentum into [-clamp_thre, clamp_thre]",
                "epoch_activate_multi_step": "epoch activate the multi-step",
                "epoch_activate_sym": "epoch activate the symmetric loss",
                "epoch_list_fixed_deep_smoother_network": "epoch_list_fixed_deep_smoother_network",
                "epoch_list_fixed_momentum_network": "list of epoch, fix the momentum network",
                "load_trained_affine_net": "load the trained affine network",
                "lr_for_multi_step": "if reset_lr_for_multi_step, reset learning rate when multi-step begins",
                "mermaid_net_json_pth": "the path for mermaid settings json",
                "num_step": "compute multi-step loss",
                "optimize_momentum_network": "if true, optimize the momentum network",
                "reset_lr_for_multi_step": "if True, reset learning rate when multi-step begins",
                "sym_factor": "factor on symmetric loss",
                "using_affine_init": "if ture, deploy an affine network before mermaid-net",
                "using_physical_coord": "use physical coordinate system"
            }
        },
        "save_3d_img_on": "saving fig",
        "save_fig_on": "saving fig",
        "train": "if is in train mode",
        "use_physical_coord": "Keep physical spacing"
    }
}